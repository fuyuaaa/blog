---
title: JVM内存管理和垃圾回收（待补充）
date: 2019-01-24 23:48:38
tags: [JVM, GC]
categories: Java基础
---
## 1、JAVA程序执行过程
![avatar](/pics/JAVA程序执行过程.png)

- 如上图，一个java程序执行时，先有编译器将 .java 文件编译为 .class 文件；再交由类加载器加载，加载完毕之后，由执行引擎执行。
- 在整个程序执行过程中，JVM会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区），即JVM内存。jvm内存管理就是针对这一段空间的。

## 2、JVM 内存管理

- JVM内存区域可以分为线程共享和非线程共享两部分，线程共享的有堆和方法区，非线程共享的有虚拟机栈，本地方法栈和程序计数器。

![avatar](/pics/JVM内存区域.jpg)

### 程序计数器

- 程序计数器是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。- - 摘自《深入理解Java虚拟机》

### 虚拟机栈
VM Stack，也叫方法栈、栈内存，由n个栈帧组成
![avatar](/pics/VM Stack.png)

- 每个方法被执行时，就会产生一个栈帧，用于存储局部变量表、动态链接、操作数、方法出口等信息。
- 方法的执行过程就是栈帧在JVM中出栈和入栈的过程。 
- 局部变量表中存放的是各种基本数据类型，如boolean、byte、char、等8种，及引用类型（存放的是指向各个对象的内存地址），因此，它有一个特点：内存空间可以在编译期间就确定，运行期不在改变。这个内存区域会有两种可能的Java异常：StackOverFlowError和OutOfMemoryError。 
	- StackOverflowError代表的是，当栈深度超过虚拟机分配给线程的栈大小时就会出现此error
	- OutofMemoryError代表的是，当再申请新的内存时，虚拟机分配给线程的内存大小中无法再分配新的内存，就会出现此error 

### 堆

- Heap，被所有线程共享；用来保存new的对象


在Heap 中分配一定的内存来保存对象实例，实际上也只是保存对象实例的属性值，属性的类型和对象本身的类型标记等，并不保存对象的方法（以帧栈的形式保存在Stack中）,在Heap 中分配一定的内存保存对象实例。而对象实例在Heap 中分配好以后，需要在Stack中保存一个4字节的Heap 内存地址，用来定位该对象实例在Heap 中的位置，便于找到该对象实例，是垃圾回收的主要场所。

### 方法区
- Method Area 


Object Class Data(加载类的类定义数据) 是存储在方法区的。除此之外，常量、静态变量、JIT(即时编译器)编译后的代码也都在方法区。正因为方法区所存储的数据与堆有一种类比关系，所以它还被称为 Non-Heap。

##### 运行时常量池（Runtime Constant Pool） RCP

- 主要用于存放在编译过程中产生的字面量（字面量简单理解就是常量）和引用。

[fuyuaaa](https://github.com/fuyuaaa/)
